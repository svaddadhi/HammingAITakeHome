This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-29T00:11:47.999Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
docs/
  DESIGN.md
src/
  analyzer/
    responseAnalyzer.ts
  call-manager/
    client.ts
  discovery/
    conversationTree.ts
  orchestrator/
    discoveryOrchestrator.ts
  transcription/
    transcriptionService.ts
  utils/
    logger.ts
  visualization/
    progressVisualizer.ts
  webhook/
    index.ts
  index.ts
  server.ts
.gitignore
eslint.config.js
package.json
README.md
tsconfig.json

================================================================
Repository Files
================================================================

================
File: docs/DESIGN.md
================
I'll create a comprehensive design document for your voice agent discovery system. Let me break this down into clear, logical sections that will guide the implementation.

# Voice Agent Discovery System Design Document

## System Overview

The Voice Agent Discovery System is designed to automatically explore and map out the conversation paths possible with AI voice agents. It systematically places calls, processes responses, and builds a comprehensive map of the agent's capabilities through synthetic conversations. Think of it as an automated explorer that charts unknown conversational territory, similar to how a web crawler discovers and maps websites.

## Core Architecture

### Component Structure

The system is organized into several key modules that work together:

1. Discovery Orchestrator

   - Acts as the central brain of the system
   - Manages the overall discovery process
   - Maintains the state of exploration
   - Coordinates between other components
   - Implements backoff and retry strategies

2. Call Manager

   - Handles all interactions with the phone API endpoints
   - Manages rate limiting and concurrent calls
   - Implements retry logic for failed calls
   - Tracks call status and recordings

3. Conversation Analyzer

   - Processes audio recordings into text
   - Analyzes responses to identify new paths
   - Determines appropriate follow-up prompts
   - Identifies when a conversation branch is complete

4. State Manager

   - Tracks discovered conversation paths
   - Maintains the conversation tree structure
   - Identifies unexplored branches
   - Prevents redundant exploration

5. Progress Reporter
   - Provides real-time console updates
   - Generates visual representation of the discovery process
   - Logs important events and milestones
   - Creates final report of discovered paths

### Data Structures

The conversation tree structure is fundamental to this system. Each node represents a conversation state and contains:

```typescript
interface ConversationNode {
  id: string;
  prompt: string;
  response: string;
  children: ConversationNode[];
  status: "unexplored" | "in-progress" | "completed";
  metadata: {
    timestamp: Date;
    callId: string;
    depth: number;
    path: string[];
  };
}
```

## Process Flow

1. Initial Setup Phase

   - System configuration validation
   - API connectivity testing
   - Setting up webhook server
   - Initializing state management

2. Discovery Phase

   - Start with root-level prompts
   - Queue exploration tasks
   - Process responses
   - Identify new branches
   - Update conversation tree

3. Analysis Phase

   - Process audio recordings
   - Extract meaningful information
   - Identify conversation patterns
   - Detect terminal states

4. Documentation Phase
   - Generate visual representation
   - Create detailed path documentation
   - Export discovered scenarios

## Key Algorithms

### Path Discovery Algorithm

The system uses a modified breadth-first search approach to explore conversation paths:

1. Start with initial greeting
2. For each response:
   - Analyze content
   - Generate relevant follow-up prompts
   - Queue new exploration tasks
3. Track exploration depth
4. Implement cycle detection
5. Handle terminal states

### Response Analysis

Implements natural language processing to:

1. Categorize responses
2. Identify key information requests
3. Detect conversation state changes
4. Recognize completion signals

## Error Handling and Resilience

The system implements multiple layers of error handling:

1. Call-Level Resilience

   - Retry logic for failed calls
   - Exponential backoff strategy
   - Circuit breaker pattern for API calls

2. State-Level Resilience
   - Periodic state snapshots
   - Recovery mechanisms
   - Progress preservation

## Performance Considerations

1. Concurrency Management

   - Parallel call processing
   - Rate limiting compliance
   - Resource utilization control

2. Memory Management
   - Efficient tree structure
   - Periodic cleanup
   - Resource poolingI'll create a comprehensive design document for your voice agent discovery system. Let me break this down into clear, logical sections that will guide the implementation.

# Voice Agent Discovery System Design Document

## System Overview

The Voice Agent Discovery System is designed to automatically explore and map out the conversation paths possible with AI voice agents. It systematically places calls, processes responses, and builds a comprehensive map of the agent's capabilities through synthetic conversations. Think of it as an automated explorer that charts unknown conversational territory, similar to how a web crawler discovers and maps websites.

## Core Architecture

### Component Structure

The system is organized into several key modules that work together:

1. Discovery Orchestrator

   - Acts as the central brain of the system
   - Manages the overall discovery process
   - Maintains the state of exploration
   - Coordinates between other components
   - Implements backoff and retry strategies

2. Call Manager

   - Handles all interactions with the phone API endpoints
   - Manages rate limiting and concurrent calls
   - Implements retry logic for failed calls
   - Tracks call status and recordings

3. Conversation Analyzer

   - Processes audio recordings into text
   - Analyzes responses to identify new paths
   - Determines appropriate follow-up prompts
   - Identifies when a conversation branch is complete

4. State Manager

   - Tracks discovered conversation paths
   - Maintains the conversation tree structure
   - Identifies unexplored branches
   - Prevents redundant exploration

5. Progress Reporter
   - Provides real-time console updates
   - Generates visual representation of the discovery process
   - Logs important events and milestones
   - Creates final report of discovered paths

### Data Structures

The conversation tree structure is fundamental to this system. Each node represents a conversation state and contains:

```typescript
interface ConversationNode {
  id: string;
  prompt: string;
  response: string;
  children: ConversationNode[];
  status: "unexplored" | "in-progress" | "completed";
  metadata: {
    timestamp: Date;
    callId: string;
    depth: number;
    path: string[];
  };
}
```

## Process Flow

1. Initial Setup Phase

   - System configuration validation
   - API connectivity testing
   - Setting up webhook server
   - Initializing state management

2. Discovery Phase

   - Start with root-level prompts
   - Queue exploration tasks
   - Process responses
   - Identify new branches
   - Update conversation tree

3. Analysis Phase

   - Process audio recordings
   - Extract meaningful information
   - Identify conversation patterns
   - Detect terminal states

4. Documentation Phase
   - Generate visual representation
   - Create detailed path documentation
   - Export discovered scenarios

## Key Algorithms

### Path Discovery Algorithm

The system uses a modified breadth-first search approach to explore conversation paths:

1. Start with initial greeting
2. For each response:
   - Analyze content
   - Generate relevant follow-up prompts
   - Queue new exploration tasks
3. Track exploration depth
4. Implement cycle detection
5. Handle terminal states

### Response Analysis

Implements natural language processing to:

1. Categorize responses
2. Identify key information requests
3. Detect conversation state changes
4. Recognize completion signals

## Error Handling and Resilience

The system implements multiple layers of error handling:

1. Call-Level Resilience

   - Retry logic for failed calls
   - Exponential backoff strategy
   - Circuit breaker pattern for API calls

2. State-Level Resilience
   - Periodic state snapshots
   - Recovery mechanisms
   - Progress preservation

## Performance Considerations

1. Concurrency Management

   - Parallel call processing
   - Rate limiting compliance
   - Resource utilization control

2. Memory Management
   - Efficient tree structure
   - Periodic cleanup
   - Resource pooling

## Monitoring and Debugging

The system provides comprehensive monitoring through:

1. Real-time console updates
2. Progress visualization
3. Detailed logging
4. Performance metrics

## Extension Points

The system is designed to be extensible in several ways:

1. New Voice Agent Types

   - Pluggable agent type handlers
   - Custom response processors

2. Additional Analysis Capabilities

   - Custom analyzers
   - New metric collectors

3. Alternative Output Formats
   - Custom report generators
   - Different visualization options

## Implementation Guidelines

1. Code Organization

   - Clear module boundaries
   - Dependency injection
   - Interface-based design
   - Comprehensive documentation

2. Testing Strategy
   - Unit tests for core logic
   - Integration tests for API interaction
   - Mock services for development
   - Scenario-based testing

Would you like me to elaborate on any particular aspect of this design? I can provide more detailed information about specific components or discuss potential implementation challenges and their solutions.

## Monitoring and Debugging

The system provides comprehensive monitoring through:

1. Real-time console updates
2. Progress visualization
3. Detailed logging
4. Performance metrics

## Extension Points

The system is designed to be extensible in several ways:

1. New Voice Agent Types

   - Pluggable agent type handlers
   - Custom response processors

2. Additional Analysis Capabilities

   - Custom analyzers
   - New metric collectors

3. Alternative Output Formats
   - Custom report generators
   - Different visualization options

## Implementation Guidelines

1. Code Organization

   - Clear module boundaries
   - Dependency injection
   - Interface-based design
   - Comprehensive documentation

2. Testing Strategy
   - Unit tests for core logic
   - Integration tests for API interaction
   - Mock services for development
   - Scenario-based testing

================
File: src/analyzer/responseAnalyzer.ts
================
import logger from "../utils/logger.js";

interface AnalysisResult {
  identifiedPaths: string[];
  isTerminalState: boolean;
  confidence: number;
}

/**
 * ResponseAnalyzer processes transcribed voice agent responses to identify
 * potential conversation paths and determine appropriate follow-up prompts.
 * It uses simple heuristics to identify meaningful paths while avoiding
 * redundant explorations.
 */
export class ResponseAnalyzer {
  // Common phrases that indicate options or choices
  private static readonly OPTION_INDICATORS = [
    "would you like",
    "you can",
    "options are",
    "we offer",
    "we can",
    "choose",
    "select",
    "either",
  ];

  // Phrases that might indicate a terminal state
  private static readonly TERMINAL_INDICATORS = [
    "goodbye",
    "thank you for calling",
    "have a nice day",
    "is there anything else",
    "end of our call",
  ];

  /**
   * Analyzes a transcribed response to identify potential conversation paths
   * @param response - Transcribed text from the voice agent
   * @returns Analysis result containing identified paths and state information
   */
  public async analyzeResponse(response: string): Promise<AnalysisResult> {
    try {
      const normalizedResponse = response.toLowerCase();

      // Check for terminal state
      const isTerminalState = this.isTerminalState(normalizedResponse);

      // Identify potential paths
      const identifiedPaths = await this.identifyPaths(normalizedResponse);

      // Calculate confidence based on identified patterns
      const confidence = this.calculateConfidence(identifiedPaths);

      logger.info("Response analysis completed", {
        pathsIdentified: identifiedPaths.length,
        isTerminal: isTerminalState,
        confidence,
      });

      return {
        identifiedPaths,
        isTerminalState,
        confidence,
      };
    } catch (error) {
      logger.error("Error analyzing response", {
        error: error instanceof Error ? error.message : "Unknown error",
        response: response.substring(0, 100), // Log first 100 chars for context
      });
      throw error;
    }
  }

  /**
   * Generates appropriate follow-up prompts based on identified paths
   * @param paths - Array of identified potential paths
   * @returns Array of follow-up prompts
   */
  public generateFollowUpPrompts(paths: string[]): string[] {
    return paths.map((path) => {
      // Generate contextually appropriate prompts based on the path
      if (path.includes("schedule") || path.includes("appointment")) {
        return "I'd like to schedule an appointment";
      }
      if (path.includes("pricing") || path.includes("cost")) {
        return "Can you tell me about your pricing?";
      }
      if (path.includes("service") || path.includes("repair")) {
        return "What services do you offer?";
      }
      // Default to a simple selection of the path
      return `I'm interested in ${path}`;
    });
  }

  /**
   * Identifies potential conversation paths from the response
   * @param response - Normalized response text
   * @returns Array of identified paths
   * @private
   */
  private async identifyPaths(response: string): Promise<string[]> {
    const paths = new Set<string>();

    // Check for direct option indicators
    for (const indicator of ResponseAnalyzer.OPTION_INDICATORS) {
      if (response.includes(indicator)) {
        const startIndex = response.indexOf(indicator) + indicator.length;
        const segment = response.slice(startIndex, startIndex + 100); // Look at next 100 chars

        // Split by common delimiters and clean up
        const options = segment
          .split(/[,.]/)
          .map((opt) => opt.trim())
          .filter((opt) => opt.length > 3) // Filter out very short segments
          .filter((opt) => !opt.startsWith("or ") && !opt.startsWith("and ")); // Clean up connectors

        options.forEach((opt) => paths.add(opt));
      }
    }

    // Look for specific service-related keywords
    const serviceKeywords = [
      "repair",
      "maintenance",
      "installation",
      "service",
      "appointment",
    ];
    for (const keyword of serviceKeywords) {
      if (response.includes(keyword)) {
        const words = response.split(" ");
        const keywordIndex = words.findIndex((w) => w.includes(keyword));
        if (keywordIndex >= 0) {
          // Look at words around the keyword
          const contextRange = 3; // Words before and after
          const start = Math.max(0, keywordIndex - contextRange);
          const end = Math.min(words.length, keywordIndex + contextRange + 1);
          const context = words.slice(start, end).join(" ");
          paths.add(context.trim());
        }
      }
    }

    return Array.from(paths);
  }

  /**
   * Checks if the response indicates a terminal state
   * @param response - Normalized response text
   * @returns boolean indicating if this is a terminal state
   * @private
   */
  private isTerminalState(response: string): boolean {
    return ResponseAnalyzer.TERMINAL_INDICATORS.some((indicator) =>
      response.includes(indicator)
    );
  }

  /**
   * Calculates confidence score for the analysis
   * @param identifiedPaths - Array of identified paths
   * @returns confidence score between 0 and 1
   * @private
   */
  private calculateConfidence(identifiedPaths: string[]): number {
    // Simple confidence calculation based on number of paths identified
    // and presence of clear option indicators
    const pathConfidence = Math.min(identifiedPaths.length * 0.2, 0.8);
    const hasOptionIndicators = ResponseAnalyzer.OPTION_INDICATORS.some(
      (indicator) => identifiedPaths.some((path) => path.includes(indicator))
    );

    return hasOptionIndicators
      ? Math.min(pathConfidence + 0.2, 1.0)
      : pathConfidence;
  }
}

================
File: src/call-manager/client.ts
================
import axios, { AxiosResponse } from "axios";
import logger from "../utils/logger.js";
import axiosRetry from "axios-retry";

axiosRetry(axios, {
  retries: 3,
  retryDelay: axiosRetry.exponentialDelay,
});

interface CallRequest {
  phone_number: string;
  prompt: string;
  webhook_url: string;
}
interface CallResponse {
  id: string;
}

/**
 * Manages voice agent calls and recording retrieval
 * @class CallManager
 */
export class CallManager {
  /**
   * Creates a new instance of CallManager
   * @param baseUrl - Base URL for the API
   * @param token - Authentication token
   * @throws Error if baseUrl or token is missing
   */
  baseUrl: string;
  token: string;
  constructor(baseUrl: string, token: string) {
    if (!baseUrl || !token) {
      throw new Error("baseUrl and token are reuquired");
    }

    this.baseUrl = baseUrl;
    this.token = token;
  }

  /**
   * Initiates a call to the specified phone number
   * @param phoneNumber - Target phone number in E.164 format
   * @param prompt - System prompt for the voice agent
   * @param webhookUrl - URL to receive call status updates
   * @returns Promise containing the call ID
   * @throws Error if the API call fails or parameters are invalid
   */
  async startCall(
    phoneNumber: string,
    prompt: string,
    webhookUrl: string
  ): Promise<string> {
    const requestData: CallRequest = {
      phone_number: phoneNumber,
      prompt,
      webhook_url: webhookUrl,
    };
    if (!phoneNumber || !prompt || !webhookUrl) {
      throw new Error("Phone number, prompt, and webhook URL are required");
    }
    try {
      logger.info("Initiating voice agent call", { phoneNumber, webhookUrl });
      const response: AxiosResponse<CallResponse> = await axios.post(
        `${this.baseUrl}/start-call`,
        requestData,
        {
          headers: {
            Authorization: `Bearer ${this.token}`,
            "Content-Type": "application/json",
          },
        }
      );

      logger.info("Call initiated successfully", {
        callId: response.data.id,
        phoneNumber,
      });
      return response.data.id;
    } catch (error) {
      logger.error("Failed to initiate call", {
        error: error instanceof Error ? error.message : "Unknown error",
        phoneNumber,
      });
      throw new Error(
        `Failed to initiate call to ${phoneNumber}: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  async retrieveRecording(callId: string): Promise<Blob> {
    try {
      logger.info("Retrieving the recording", { id: callId });
      const response: AxiosResponse = await axios.get(
        "https://app.hamming.ai/api/media/exercise",
        {
          params: { id: callId },
          responseType: "blob",
          headers: {
            Authorization: `Bearer ${this.token}`,
          },
        }
      );
      logger.info("Successfully retrieved recording");
      return response.data;
    } catch (error) {
      logger.error("Failed to retrieve recording", {
        error: error instanceof Error ? error.message : "Unknown error",
      });

      throw new Error(
        `Failed to retrieve recording: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }
}

================
File: src/discovery/conversationTree.ts
================
import logger from "../utils/logger.js";

enum NodeStatus {
  UNEXPLORED = "unexplored",
  IN_PROGRESS = "in-progress",
  COMPLETED = "completed",
  FAILED = "failed",
}

interface CallNode {
  id: string;
  previousPrompt: string;
  responseReceived: string;
  callId: string;
  status: NodeStatus;
  children: CallNode[];
  parentId: string | null;
  timestamp: Date;
  depth: number;
  potentialPaths?: string[];
  retryCount: number;
}

/**
 * ConversationTree manages the structure and operations of the voice agent
 * conversation discovery process. It tracks all explored and unexplored paths,
 * maintains relationships between conversation nodes, and provides methods
 * for traversing and updating the conversation tree.
 */
export class ConversationTree {
  private nodes: Map<string, CallNode>;
  private rootNode: CallNode | null;
  private maxDepth: number;

  constructor(maxDepth: number = 10) {
    this.nodes = new Map();
    this.rootNode = null;
    this.maxDepth = maxDepth;
  }

  /**
   * Initializes the tree with a root node
   * @param prompt Initial prompt used to start the conversation
   * @param callId ID of the initial call
   * @returns The created root node
   */
  public initializeRoot(prompt: string, callId: string): CallNode {
    if (this.rootNode) {
      throw new Error("Tree already initialized");
    }

    const rootNode: CallNode = {
      id: "root",
      previousPrompt: prompt,
      responseReceived: "", // Will be updated when response is received
      callId: callId,
      status: NodeStatus.IN_PROGRESS,
      children: [],
      parentId: null,
      timestamp: new Date(),
      depth: 0,
      retryCount: 0,
    };

    this.rootNode = rootNode;
    this.nodes.set(rootNode.id, rootNode);

    logger.info("Conversation tree initialized with root node", {
      nodeId: rootNode.id,
      callId,
    });

    return rootNode;
  }

  /**
   * Adds a new node to the tree
   * @param parentId ID of the parent node
   * @param prompt Prompt used for this node
   * @param callId Associated call ID
   * @returns The newly created node
   */
  public addNode(parentId: string, prompt: string, callId: string): CallNode {
    const parentNode = this.nodes.get(parentId);
    if (!parentNode) {
      throw new Error(`Parent node ${parentId} not found`);
    }

    if (parentNode.depth >= this.maxDepth) {
      throw new Error(`Maximum depth ${this.maxDepth} reached`);
    }

    const newNode: CallNode = {
      id: `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      previousPrompt: prompt,
      responseReceived: "",
      callId: callId,
      status: NodeStatus.IN_PROGRESS,
      children: [],
      parentId: parentId,
      timestamp: new Date(),
      depth: parentNode.depth + 1,
      retryCount: 0,
    };

    parentNode.children.push(newNode);
    this.nodes.set(newNode.id, newNode);

    logger.info("Added new node to conversation tree", {
      nodeId: newNode.id,
      parentId,
      depth: newNode.depth,
    });

    return newNode;
  }

  /**
   * Updates a node with response information
   * @param nodeId ID of the node to update
   * @param response Response received from the voice agent
   * @param potentialPaths Potential follow-up prompts identified
   */
  public updateNodeWithResponse(
    nodeId: string,
    response: string,
    potentialPaths?: string[]
  ): void {
    const node = this.nodes.get(nodeId);
    if (!node) {
      throw new Error(`Node ${nodeId} not found`);
    }

    node.responseReceived = response;
    node.potentialPaths = potentialPaths;
    node.status = NodeStatus.COMPLETED;

    logger.info("Updated node with response", {
      nodeId,
      pathsIdentified: potentialPaths?.length ?? 0,
    });
  }

  /**
   * Updates the status of a node
   * @param nodeId ID of the node to update
   * @param status New status
   */
  public updateNodeStatus(nodeId: string, status: NodeStatus): void {
    const node = this.nodes.get(nodeId);
    if (!node) {
      throw new Error(`Node ${nodeId} not found`);
    }

    node.status = status;
    logger.info("Updated node status", { nodeId, status });
  }

  /**
   * Gets all nodes that have unexplored potential paths
   * @returns Array of nodes with unexplored paths
   */
  public getNodesWithUnexploredPaths(): CallNode[] {
    return Array.from(this.nodes.values()).filter(
      (node) =>
        node.status === NodeStatus.COMPLETED &&
        node.potentialPaths?.length > 0 &&
        node.depth < this.maxDepth
    );
  }

  /**
   * Gets the complete path from root to a specific node
   * @param nodeId ID of the target node
   * @returns Array of nodes representing the path
   */
  public getPathToNode(nodeId: string): CallNode[] {
    const path: CallNode[] = [];
    let currentNode = this.nodes.get(nodeId);

    while (currentNode) {
      path.unshift(currentNode);
      currentNode = currentNode.parentId
        ? this.nodes.get(currentNode.parentId)
        : null;
    }

    return path;
  }

  /**
   * Gets a node by its ID
   * @param nodeId ID of the node to retrieve
   * @returns The requested node or null if not found
   */
  public getNode(nodeId: string): CallNode | null {
    return this.nodes.get(nodeId) || null;
  }

  /**
   * Gets all nodes at a specific depth in the tree
   * @param depth The depth to search at
   * @returns Array of nodes at the specified depth
   */
  public getNodesAtDepth(depth: number): CallNode[] {
    return Array.from(this.nodes.values()).filter(
      (node) => node.depth === depth
    );
  }

  /**
   * Gets a summary of the tree's current state
   * @returns Object containing tree statistics
   */
  public getTreeSummary() {
    const totalNodes = this.nodes.size;
    const completedNodes = Array.from(this.nodes.values()).filter(
      (node) => node.status === NodeStatus.COMPLETED
    ).length;
    const maxDepthReached = Math.max(
      ...Array.from(this.nodes.values()).map((node) => node.depth)
    );

    return {
      totalNodes,
      completedNodes,
      maxDepthReached,
      maxAllowedDepth: this.maxDepth,
    };
  }

  /**
   * Gets all nodes in the tree
   * @returns Array of all nodes
   */
  public getAllNodes(): CallNode[] {
    return Array.from(this.nodes.values());
  }
}

================
File: src/orchestrator/discoveryOrchestrator.ts
================
import logger from "../utils/logger.js";
import { CallManager } from "../call-manager/client.js";
import { ConversationTree } from "../discovery/conversationTree.js";
import { ResponseAnalyzer } from "../analyzer/responseAnalyzer.js";
import { ProgressVisualizer } from "../visualization/progressVisualizer.js";

interface DiscoveryConfig {
  maxDepth: number;
  maxConcurrentCalls: number;
  initialPrompt: string;
  phoneNumber: string;
  webhookUrl: string;
}

interface DiscoveryState {
  isRunning: boolean;
  activeCallCount: number;
  completedCallCount: number;
  failedCallCount: number;
  lastUpdateTimestamp: Date;
}

/**
 * DiscoveryOrchestrator manages the overall process of discovering voice agent capabilities.
 * It coordinates between the CallManager, ConversationTree, and ResponseAnalyzer to
 * systematically explore and document possible conversation paths.
 */
export class DiscoveryOrchestrator {
  private readonly callManager: CallManager;
  private readonly conversationTree: ConversationTree;
  private readonly responseAnalyzer: ResponseAnalyzer;
  private readonly config: DiscoveryConfig;
  private state: DiscoveryState;
  private readonly MAX_RETRY_ATTEMPTS = 3;
  private readonly visualizer: ProgressVisualizer;

  constructor(callManager: CallManager, config: DiscoveryConfig) {
    this.callManager = callManager;
    this.config = config;
    this.conversationTree = new ConversationTree(config.maxDepth);
    this.responseAnalyzer = new ResponseAnalyzer();
    this.visualizer = new ProgressVisualizer();

    this.state = {
      isRunning: false,
      activeCallCount: 0,
      completedCallCount: 0,
      failedCallCount: 0,
      lastUpdateTimestamp: new Date(),
    };
  }

  /**
   * Starts the discovery process
   * Initializes the conversation tree and begins exploring paths
   */
  public async startDiscovery(): Promise<void> {
    if (this.state.isRunning) {
      throw new Error("Discovery process is already running");
    }

    try {
      logger.info("Starting discovery process", {
        phoneNumber: this.config.phoneNumber,
        maxDepth: this.config.maxDepth,
        maxConcurrentCalls: this.config.maxConcurrentCalls,
      });

      this.state.isRunning = true;
      this.state.lastUpdateTimestamp = new Date();

      // Start with initial call
      const callId = await this.callManager.startCall(
        this.config.phoneNumber,
        this.config.initialPrompt,
        this.config.webhookUrl
      );

      // Initialize the conversation tree with root node
      this.conversationTree.initializeRoot(this.config.initialPrompt, callId);

      this.state.activeCallCount++;

      logger.info("Initial call placed, awaiting response", { callId });
    } catch (error) {
      this.state.isRunning = false;
      logger.error("Failed to start discovery process", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
      throw error;
    }
  }

  /**
   * Processes a completed call and decides on next steps
   * @param callId ID of the completed call
   * @param response Transcribed response from the call
   */
  public async handleCallCompleted(
    callId: string,
    response: string
  ): Promise<void> {
    try {
      // Find the node associated with this call
      const node = this.conversationTree
        .getAllNodes()
        .find((node) => node.callId === callId);

      if (!node) {
        throw new Error(`No node found for call ${callId}`);
      }

      // Analyze the response and update the node
      const potentialPaths = await this.analyzePath(response);
      this.conversationTree.updateNodeWithResponse(
        node.id,
        response,
        potentialPaths
      );

      // Update state
      this.state.activeCallCount--;
      this.state.completedCallCount++;
      this.state.lastUpdateTimestamp = new Date();

      // Add visualization
      this.visualizer.visualizeTree(this.conversationTree);
      this.visualizer.visualizeProgress(this.state);
      this.visualizer.logConversationEvent(node.id, "Call Completed", {
        response: response.substring(0, 100),
        potentialPaths: potentialPaths.length,
      });

      // Explore new paths if available
      await this.exploreNextPaths();

      logger.info("Successfully processed completed call", {
        callId,
        nodeId: node.id,
        potentialPathsFound: potentialPaths.length,
      });
    } catch (error) {
      logger.error("Error processing completed call", {
        error: error instanceof Error ? error.message : "Unknown error",
        callId,
      });
      this.state.failedCallCount++;
    }
  }

  /**
   * Analyzes a response to identify potential conversation paths
   * @param response Voice agent's response
   * @returns Array of potential follow-up prompts
   * @private
   */
  private async analyzePath(response: string): Promise<string[]> {
    try {
      const analysis = await this.responseAnalyzer.analyzeResponse(response);

      if (analysis.isTerminalState) {
        logger.info("Terminal state detected in response");
        return [];
      }

      if (analysis.confidence < 0.3) {
        logger.warn("Low confidence in path analysis", {
          confidence: analysis.confidence,
        });
      }

      // Generate appropriate follow-up prompts based on identified paths
      const followUpPrompts = this.responseAnalyzer.generateFollowUpPrompts(
        analysis.identifiedPaths
      );

      logger.info("Path analysis completed", {
        identifiedPaths: analysis.identifiedPaths.length,
        followUpPrompts: followUpPrompts.length,
        confidence: analysis.confidence,
      });

      return followUpPrompts;
    } catch (error) {
      logger.error("Error in path analysis", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
      return []; // Return empty array on error
    }
  }

  /**
   * Explores the next available paths in the conversation tree
   * @private
   */
  private async exploreNextPaths(): Promise<void> {
    if (!this.state.isRunning) return;

    try {
      const unexploredNodes =
        this.conversationTree.getNodesWithUnexploredPaths();

      for (const node of unexploredNodes) {
        // Check if we can make more concurrent calls
        if (this.state.activeCallCount >= this.config.maxConcurrentCalls) {
          logger.info(
            "Maximum concurrent calls reached, waiting for completions"
          );
          break;
        }

        // Get the next prompt to try
        const nextPrompt = node.potentialPaths?.[0];
        if (!nextPrompt) continue;

        // Remove this prompt from potential paths
        node.potentialPaths = node.potentialPaths?.slice(1);

        try {
          // Make the call
          const callId = await this.callManager.startCall(
            this.config.phoneNumber,
            nextPrompt,
            this.config.webhookUrl
          );

          // Add new node to tree
          this.conversationTree.addNode(node.id, nextPrompt, callId);
          this.state.activeCallCount++;
          this.state.lastUpdateTimestamp = new Date();

          // Add visualization update
          this.visualizer.visualizeTree(this.conversationTree);
          this.visualizer.visualizeProgress(this.state);

          logger.info("Started exploration of new path", {
            parentNodeId: node.id,
            newCallId: callId,
            prompt: nextPrompt,
          });
        } catch (error) {
          logger.error("Failed to explore path", {
            error: error instanceof Error ? error.message : "Unknown error",
            parentNodeId: node.id,
            prompt: nextPrompt,
          });
        }
      }
    } catch (error) {
      logger.error("Error exploring next paths", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  /**
   * Handles failed calls
   * @param callId ID of the failed call
   */
  public async handleCallFailed(callId: string): Promise<void> {
    try {
      const node = this.conversationTree
        .getAllNodes()
        .find((node) => node.callId === callId);

      if (node) {
        // Implement retry logic
        const retryCount = node.retryCount || 0;
        if (retryCount < this.MAX_RETRY_ATTEMPTS) {
          logger.info("Retrying failed call", {
            callId,
            retryCount: retryCount + 1,
          });

          const newCallId = await this.callManager.startCall(
            this.config.phoneNumber,
            node.previousPrompt,
            this.config.webhookUrl
          );

          // Update node with new call ID and increment retry count
          node.callId = newCallId;
          node.retryCount = retryCount + 1;
        } else {
          logger.warn("Maximum retry attempts reached for call", {
            callId,
            maxAttempts: this.MAX_RETRY_ATTEMPTS,
          });
          this.state.failedCallCount++;
        }
      }

      // Update state
      this.state.activeCallCount--;
      this.state.lastUpdateTimestamp = new Date();
    } catch (error) {
      logger.error("Error handling failed call", {
        error: error instanceof Error ? error.message : "Unknown error",
        callId,
      });
    }
  }

  /**
   * Gets the current state of the discovery process
   */
  public getDiscoveryState() {
    return {
      ...this.state,
      treeSummary: this.conversationTree.getTreeSummary(),
    };
  }

  /**
   * Stops the discovery process
   */
  public stopDiscovery(): void {
    this.state.isRunning = false;
    logger.info("Discovery process stopped", this.getDiscoveryState());
  }
}

================
File: src/transcription/transcriptionService.ts
================
import { createClient } from "@deepgram/sdk";
import logger from "../utils/logger.js";

interface TranscriptionResult {
  text: string;
  confidence: number;
}

interface DeepgramResponse {
  results: {
    channels: [
      {
        alternatives: [
          {
            transcript: string;
            confidence: number;
          }
        ];
      }
    ];
  };
}

/**
 * TranscriptionService handles the conversion of audio recordings to text
 * using the Deepgram API. It provides methods for transcribing both
 * audio blobs and files.
 */
export class TranscriptionService {
  private deepgramClient;

  /**
   * Creates a new instance of TranscriptionService
   * @param apiKey - Deepgram API key
   * @throws Error if API key is not provided
   */
  constructor(apiKey: string) {
    if (!apiKey) {
      throw new Error("Deepgram API key is required");
    }

    this.deepgramClient = createClient(apiKey);
  }

  /**
   * Transcribes an audio blob to text
   * @param audioBlob - The audio blob to transcribe
   * @returns Promise containing the transcription result
   */
  async transcribeAudio(audioBlob: Blob): Promise<TranscriptionResult> {
    try {
      logger.info("Starting audio transcription");

      const buffer = Buffer.from(await audioBlob.arrayBuffer());

      const { result, error } =
        await this.deepgramClient.listen.prerecorded.transcribeFile(buffer, {
          model: "nova-2",
          smart_format: true,
        });

      if (error) {
        throw error;
      }

      // Extract the transcript and confidence from the response
      const transcript =
        result.results?.channels[0]?.alternatives[0]?.transcript;
      const confidence =
        result.results?.channels[0]?.alternatives[0]?.confidence;

      if (!transcript) {
        throw new Error("No transcript received from Deepgram");
      }

      logger.info("Successfully transcribed audio", {
        confidenceScore: confidence,
        transcriptLength: transcript.length,
      });

      return {
        text: transcript,
        confidence: confidence || 0,
      };
    } catch (error) {
      logger.error("Failed to transcribe audio", {
        error: error instanceof Error ? error.message : "Unknown error",
      });

      throw new Error(
        `Transcription failed: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }

  /**
   * Transcribes audio from a URL
   * @param audioUrl - URL of the audio file to transcribe
   * @returns Promise containing the transcription result
   */
  async transcribeUrl(audioUrl: string): Promise<TranscriptionResult> {
    try {
      logger.info("Starting URL audio transcription", { url: audioUrl });

      const { result, error } =
        await this.deepgramClient.listen.prerecorded.transcribeUrl(
          {
            url: audioUrl,
          },
          {
            model: "nova-2",
            smart_format: true,
          }
        );

      if (error) {
        throw error;
      }

      const transcript =
        result.results?.channels[0]?.alternatives[0]?.transcript;
      const confidence =
        result.results?.channels[0]?.alternatives[0]?.confidence;

      if (!transcript) {
        throw new Error("No transcript received from Deepgram");
      }

      logger.info("Successfully transcribed URL audio", {
        url: audioUrl,
        confidenceScore: confidence,
        transcriptLength: transcript.length,
      });

      return {
        text: transcript,
        confidence: confidence || 0,
      };
    } catch (error) {
      logger.error("Failed to transcribe URL audio", {
        error: error instanceof Error ? error.message : "Unknown error",
        url: audioUrl,
      });

      throw new Error(
        `URL transcription failed: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
    }
  }
}

================
File: src/utils/logger.ts
================
import winston from "winston";

const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    // Write all logs with importance level of 'info' or less to combined.log
    new winston.transports.File({ filename: "logs/combined.log" }),
    // Write all logs with importance level of 'error' or less to error.log
    new winston.transports.File({ filename: "logs/error.log", level: "error" }),
    // Write to console during development
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
  ],
});

export default logger;

================
File: src/visualization/progressVisualizer.ts
================
import { ConversationTree } from "../discovery/conversationTree.js";
import logger from "../utils/logger.js";

interface VisualizationNode {
  id: string;
  prompt: string;
  response: string;
  status: string;
  depth: number;
  children: VisualizationNode[];
}

/**
 * ProgressVisualizer handles real-time visualization of the discovery process,
 * including conversation tree structure and progress tracking.
 */
export class ProgressVisualizer {
  private static readonly TREE_CHARS = {
    vertical: "│",
    horizontal: "──",
    corner: "└",
    junction: "├",
  };

  /**
   * Generates a visual representation of the current conversation tree
   * @param tree The conversation tree to visualize
   */
  public visualizeTree(tree: ConversationTree): void {
    console.clear(); // Clear console for fresh visualization
    const nodes = tree.getAllNodes();
    const rootNode = nodes.find((node) => node.parentId === null);

    if (!rootNode) {
      logger.warn("No root node found in conversation tree");
      return;
    }

    // Convert to visualization format
    const visualTree = this.convertToVisualNode(rootNode, nodes);

    // Print tree header
    console.log("\n=== Conversation Tree Visualization ===\n");

    // Render tree structure
    this.renderNode(visualTree, "", true);

    // Print summary
    this.printTreeSummary(tree);
  }

  /**
   * Displays the current progress of the discovery process
   * @param state Current state of the discovery process
   */
  public visualizeProgress(state: any): void {
    console.log("\n=== Discovery Progress ===");
    console.log(`Active Calls: ${state.activeCallCount}`);
    console.log(`Completed Calls: ${state.completedCallCount}`);
    console.log(`Failed Calls: ${state.failedCallCount}`);
    console.log(`Last Update: ${state.lastUpdateTimestamp}`);
    console.log("===========================\n");
  }

  /**
   * Logs a conversation event with formatted output
   * @param nodeId ID of the conversation node
   * @param event Type of event
   * @param details Additional event details
   */
  public logConversationEvent(
    nodeId: string,
    event: string,
    details: any
  ): void {
    const timestamp = new Date().toISOString();
    console.log(`\n[${timestamp}] ${event.toUpperCase()}`);
    console.log(`Node: ${nodeId}`);
    console.log("Details:", JSON.stringify(details, null, 2));
    console.log("---");
  }

  /**
   * Converts a tree node to visualization format
   * @param node Current node
   * @param allNodes All nodes in the tree
   * @private
   */
  private convertToVisualNode(node: any, allNodes: any[]): VisualizationNode {
    const children = allNodes.filter((n) => n.parentId === node.id);
    return {
      id: node.id,
      prompt: node.previousPrompt,
      response: node.responseReceived,
      status: node.status,
      depth: node.depth,
      children: children.map((child) =>
        this.convertToVisualNode(child, allNodes)
      ),
    };
  }

  /**
   * Renders a node and its children in the tree visualization
   * @param node Node to render
   * @param prefix Current prefix for tree structure
   * @param isLast Whether this is the last child in its parent
   * @private
   */
  private renderNode(
    node: VisualizationNode,
    prefix: string,
    isLast: boolean
  ): void {
    // Construct the line for this node
    const connector = isLast
      ? ProgressVisualizer.TREE_CHARS.corner
      : ProgressVisualizer.TREE_CHARS.junction;
    console.log(
      `${prefix}${connector}${ProgressVisualizer.TREE_CHARS.horizontal}` +
        `[${node.status}] ${this.truncateText(node.prompt, 40)}`
    );

    // Add response if available
    if (node.response) {
      console.log(
        `${prefix}${isLast ? " " : ProgressVisualizer.TREE_CHARS.vertical}   ` +
          `Response: "${this.truncateText(node.response, 60)}"`
      );
    }

    // Render children
    const childPrefix =
      prefix +
      (isLast ? "    " : ProgressVisualizer.TREE_CHARS.vertical + "   ");
    node.children.forEach((child, index) => {
      this.renderNode(child, childPrefix, index === node.children.length - 1);
    });
  }

  /**
   * Prints a summary of the conversation tree
   * @param tree Conversation tree
   * @private
   */
  private printTreeSummary(tree: ConversationTree): void {
    const summary = tree.getTreeSummary();
    console.log("\n=== Tree Summary ===");
    console.log(`Total Nodes: ${summary.totalNodes}`);
    console.log(`Completed Nodes: ${summary.completedNodes}`);
    console.log(`Max Depth Reached: ${summary.maxDepthReached}`);
    console.log(`Max Allowed Depth: ${summary.maxAllowedDepth}`);
    console.log("==================\n");
  }

  /**
   * Truncates text to a specified length
   * @param text Text to truncate
   * @param maxLength Maximum length
   * @private
   */
  private truncateText(text: string, maxLength: number): string {
    return text.length > maxLength
      ? text.substring(0, maxLength - 3) + "..."
      : text;
  }
}

================
File: src/webhook/index.ts
================
import { Router, Request, Response } from "express";
import { CallManager } from "../call-manager/client.js";
import { DiscoveryOrchestrator } from "../orchestrator/discoveryOrchestrator.js";
import { TranscriptionService } from "../transcription/transcriptionService.js";
import logger from "../utils/logger.js";

interface WebhookPayload {
  id: string;
  status: "initiated" | "in-progress" | "completed" | "failed";
  recording_available: boolean;
}

/**
 * WebhookHandler manages incoming notifications about voice agent calls.
 * It coordinates with the DiscoveryOrchestrator to manage the discovery process
 * and uses TranscriptionService to process audio recordings.
 */
export class WebhookHandler {
  private router: Router;
  private callManager: CallManager;
  private orchestrator: DiscoveryOrchestrator;
  private transcriptionService: TranscriptionService;

  constructor(
    callManager: CallManager,
    orchestrator: DiscoveryOrchestrator,
    transcriptionService: TranscriptionService
  ) {
    this.router = Router();
    this.callManager = callManager;
    this.orchestrator = orchestrator;
    this.transcriptionService = transcriptionService;
    this.configureRoutes();
  }

  private configureRoutes(): void {
    this.router.post("/callback", this.handleWebhook.bind(this));
  }

  private async handleWebhook(req: Request, res: Response): Promise<void> {
    try {
      const payload = this.validatePayload(req.body);

      logger.info("Received webhook notification", {
        callId: payload.id,
        status: payload.status,
        recordingAvailable: payload.recording_available,
      });

      // Process webhook based on status
      await this.processWebhook(payload);

      // Send immediate acknowledgment
      res.status(200).json({ received: true });
    } catch (error) {
      logger.error("Error processing webhook", {
        error: error instanceof Error ? error.message : "Unknown error",
        body: req.body,
      });

      res.status(400).json({
        error: error instanceof Error ? error.message : "Unknown error",
      });
    }
  }

  private validatePayload(body: any): WebhookPayload {
    if (!body?.id || !body?.status) {
      throw new Error("Invalid webhook payload: missing required fields");
    }

    const validStatuses = ["initiated", "in-progress", "completed", "failed"];
    if (!validStatuses.includes(body.status)) {
      throw new Error(`Invalid status: ${body.status}`);
    }

    return body as WebhookPayload;
  }

  private async processWebhook(payload: WebhookPayload): Promise<void> {
    switch (payload.status) {
      case "completed":
        if (payload.recording_available) {
          try {
            // Retrieve the recording
            const recording = await this.callManager.retrieveRecording(
              payload.id
            );

            // Transcribe the recording
            logger.info("Starting transcription for call", {
              callId: payload.id,
            });
            const transcriptionResult =
              await this.transcriptionService.transcribeAudio(recording);

            logger.info("Transcription completed", {
              callId: payload.id,
              confidence: transcriptionResult.confidence,
            });

            // Pass transcribed text to orchestrator for processing
            await this.orchestrator.handleCallCompleted(
              payload.id,
              transcriptionResult.text
            );
          } catch (error) {
            logger.error("Failed to process recording", {
              error: error instanceof Error ? error.message : "Unknown error",
              callId: payload.id,
            });

            await this.orchestrator.handleCallFailed(payload.id);
          }
        }
        break;

      case "failed":
        await this.orchestrator.handleCallFailed(payload.id);
        break;

      case "initiated":
      case "in-progress":
        logger.info("Call status update", {
          callId: payload.id,
          status: payload.status,
        });
        break;
    }
  }

  public getRouter(): Router {
    return this.router;
  }
}

================
File: src/index.ts
================
import Server from "./server.js";
import { CallManager } from "./call-manager/client.js";
import { WebhookHandler } from "./webhook/index.js";
import { DiscoveryOrchestrator } from "./orchestrator/discoveryOrchestrator.js";
import { TranscriptionService } from "./transcription/transcriptionService.js";
import logger from "./utils/logger.js";

async function startServer() {
  try {
    // Initialize services
    const callManager = new CallManager(
      process.env.BASE_URL!,
      process.env.API_TOKEN!
    );

    const transcriptionService = new TranscriptionService(
      process.env.DEEPGRAM_API_KEY!
    );

    // Initialize orchestrator
    const orchestrator = new DiscoveryOrchestrator(callManager, {
      maxDepth: 5,
      maxConcurrentCalls: 3,
      initialPrompt: "Hello, I'd like to learn about your services",
      phoneNumber: process.env.TARGET_PHONE_NUMBER!,
      webhookUrl: process.env.WEBHOOK_URL!,
    });

    // Initialize webhook handler with all dependencies
    const webhookHandler = new WebhookHandler(
      callManager,
      orchestrator,
      transcriptionService
    );

    // Initialize and configure server
    const server = new Server(Number(process.env.PORT) || 3000);

    // Add webhook routes
    server.addRoute("/webhook", webhookHandler.getRouter());

    // Start the server
    await server.start();

    // Start the discovery process
    await orchestrator.startDiscovery();

    logger.info("Application started successfully");
  } catch (error) {
    logger.error("Failed to start application", {
      error: error instanceof Error ? error.message : "Unknown error",
    });
    process.exit(1);
  }
}

startServer();

================
File: src/server.ts
================
import express, { Express, Request, Response, NextFunction } from "express";
import cors from "cors";
import helmet from "helmet";
import logger from "./utils/logger.js";

interface AppError extends Error {
  status?: number;
}

class Server {
  private app: Express;
  private port: number;

  constructor(port: number = 3000) {
    this.app = express();
    this.port = port;

    this.configureMiddleware();

    this.configureErrorHandling();
  }

  private configureMiddleware(): void {
    this.app.use(express.json());

    // Parse URL-encoded bodies (useful for form submissions)
    this.app.use(express.urlencoded({ extended: true }));

    this.app.use(
      cors({
        origin: process.env.ALLOWED_ORIGINS?.split(",") || "*",
        methods: ["POST", "GET", "OPTIONS"],
        allowedHeaders: ["Content-Type", "Authorization"],
      })
    );

    // Add security headers
    this.app.use(helmet());

    this.app.use((req: Request, res: Response, next: NextFunction) => {
      logger.info("Incoming request", {
        method: req.method,
        path: req.path,
        ip: req.ip,
      });
      next();
    });
  }

  private configureErrorHandling(): void {
    this.app.use((req: Request, res: Response, next: NextFunction) => {
      const error: AppError = new Error("Not Found");
      error.status = 404;
      next(error);
    });

    this.app.use(
      (error: AppError, req: Request, res: Response, next: NextFunction) => {
        logger.error("Server error", {
          error: error.message,
          stack: error.stack,
          path: req.path,
          method: req.method,
        });

        res.status(error.status || 500).json({
          error: {
            message: error.message || "Internal server error",
            status: error.status || 500,
          },
        });
      }
    );
  }

  /**
   * Adds a new route to the Express application
   * @param path - The URL path for the route
   * @param router - The Express router to handle the route
   */
  public addRoute(path: string, router: express.Router): void {
    this.app.use(path, router);
    logger.info(`Route added: ${path}`);
  }

  /**
   * Starts the server listening on the configured port
   * @returns Promise that resolves when the server is listening
   */
  public async start(): Promise<void> {
    try {
      await new Promise<void>((resolve) => {
        this.app.listen(this.port, () => {
          logger.info(`Server is running on port ${this.port}`);
          resolve();
        });
      });
    } catch (error) {
      logger.error("Failed to start server", {
        error: error instanceof Error ? error.message : "Unknown error",
        port: this.port,
      });
      throw error;
    }
  }
}

export default Server;

================
File: .gitignore
================
node_modules/
.env

================
File: eslint.config.js
================
import globals from "globals";
import pluginJs from "@eslint/js";
import tseslint from "typescript-eslint";


/** @type {import('eslint').Linter.Config[]} */
export default [
  {files: ["**/*.{js,mjs,cjs,ts}"]},
  {languageOptions: { globals: globals.browser }},
  pluginJs.configs.recommended,
  ...tseslint.configs.recommended,
];

================
File: package.json
================
{
  "name": "hammingaitakehome",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "type": "module",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "build": "tsc",
    "start": "node --loader ts-node/esm src/index.ts",
    "dev": "node --loader ts-node/esm --no-warnings src/index.ts"
},
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@eslint/js": "^9.15.0",
    "@types/cors": "^2.8.17",
    "@types/express": "^5.0.0",
    "@types/node": "^22.10.0",
    "eslint": "^9.15.0",
    "globals": "^15.12.0",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.7.2",
    "typescript-eslint": "^8.16.0"
  },
  "dependencies": {
    "@deepgram/sdk": "^3.9.0",
    "axios": "^1.7.8",
    "axios-retry": "^4.5.0",
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "helmet": "^8.0.0",
    "winston": "^3.17.0"
  }
}

================
File: README.md
================
# HammingAITakeHome

================
File: tsconfig.json
================
{
    "compilerOptions": {
        "target": "ES2020",
        "module": "ES2022",
        "moduleResolution": "node",
        "esModuleInterop": true,
        "outDir": "dist",
        "strict": true,
        "sourceMap": true,
        "allowJs": true,
        "types": ["node"]
    },
    "include": ["src/**/*"],
    "ts-node": {
        "esm": true,
        "experimentalSpecifierResolution": "node"
    }
}
